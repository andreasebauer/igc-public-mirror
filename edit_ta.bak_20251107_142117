#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s nullglob

usage() {
  echo "Usage: $0 [ -rb ] [ --files FILE [FILE ...] ]"
  echo "  normal run:      cat edits | $0 --files <one-or-more-files>"
  echo "  rollback:        $0 -rb --files <one-or-more-files>"
  echo "  auto-rollback:   $0 -rb         # restores newest snapshot (single or group)"
}

RB=0
declare -a FILES=()

# parse args
while (($#)); do
  case "$1" in
    -rb) RB=1; shift ;;
    --files)
      shift
      while (($#)) && [[ "$1" != -* ]]; do
        FILES+=("$1"); shift
      done
      ;;
    -h|--help) usage; exit 0 ;;
    *) 
      # tolerate extra tokens only in auto-rollback mode
      if [[ "$RB" -eq 1 ]]; then shift; else usage; exit 2; fi
      ;;
  esac
done

# helpers
_restore_one() {
  local snap="$1" base ts
  [[ -f "$snap" ]] || { echo "FATAL: snapshot not found: $snap" >&2; exit 2; }
  if [[ "$snap" =~ (.*)\.ta_bak_g_([0-9]{17})$ ]]; then
    base="${BASH_REMATCH[1]}"; ts="${BASH_REMATCH[2]}"
  elif [[ "$snap" =~ (.*)\.ta_bak_([0-9]{17})$ ]]; then
    base="${BASH_REMATCH[1]}"; ts="${BASH_REMATCH[2]}"
  else
    echo "FATAL: unrecognized snapshot name: $snap" >&2; exit 2
  fi
  cp -f -- "$snap" "$base" || { echo "FATAL: restore copy failed for $base" >&2; exit 2; }
  cmp -s "$snap" "$base"   || { echo "FATAL: restore verification failed for $base" >&2; exit 2; }
  echo "ROLLED BACK $base from $snap"
}

_auto_rollback() {
  local newest_ts="" newest_snap="" kind=""
  # find newest snapshot anywhere
  while IFS= read -r -d '' f; do
    local ts="${f##*_}"
    [[ -n "$ts" ]] || continue
    if [[ "$ts" > "$newest_ts" ]]; then
      newest_ts="$ts"
      newest_snap="$f"
      if [[ "$f" == *.ta_bak_g_* ]]; then kind="group"; else kind="file"; fi
    fi
  done < <(find . -type f \( -name '*.ta_bak_g_*' -o -name '*.ta_bak_*' \) -print0)

  [[ -n "$newest_ts" ]] || { echo "NO BACKUP FOUND"; exit 1; }

  if [[ "$kind" == "group" ]]; then
    # restore all files that share the same group TS
    while IFS= read -r -d '' b; do
      _restore_one "$b"
    done < <(find . -type f -name "*\.ta_bak_g_${newest_ts}" -print0)
  else
    _restore_one "$newest_snap"
  fi
}

# rollback mode
if [[ "$RB" -eq 1 ]]; then
  if ((${#FILES[@]} == 0)); then
    _auto_rollback
    exit 0
  fi

  # newest snapshot among the listed files
  newest_ts=""; newest_kind=""; newest_base=""
  for F in "${FILES[@]}"; do
    for b in "$F".ta_bak_g_* "$F".ta_bak_[0-9]*; do
      [[ -e "$b" ]] || continue
      ts="${b##*_}"
      [[ -n "$ts" ]] || continue
      if [[ "$ts" > "$newest_ts" ]]; then
        newest_ts="$ts"
        if [[ "$b" == *.ta_bak_g_* ]]; then
          newest_kind="group"
        else
          newest_kind="file"; newest_base="$F"
        fi
      fi
    done
  done

  [[ -n "$newest_ts" ]] || { echo "NO BACKUP FOUND"; exit 1; }

  if [[ "$newest_kind" == "group" ]]; then
    for F in "${FILES[@]}"; do
      B="$F.ta_bak_g_$newest_ts"
      if [[ -f "$B" ]]; then _restore_one "$B"; else echo "NO GROUP BACKUP for $F"; fi
    done
  else
    [[ -n "$newest_base" ]] || { echo "NO BACKUP FILE TARGET" >&2; exit 1; }
    chosen=""; best=""
    for b in "$newest_base".ta_bak_[0-9]*; do
      [[ -e "$b" ]] || continue
      ts="${b##*_}"
      if [[ -z "$best" || "$ts" > "$best" ]]; then best="$ts"; chosen="$b"; fi
    done
    [[ -n "$chosen" ]] || { echo "NO BACKUP for $newest_base" >&2; exit 1; }
    _restore_one "$chosen"
  fi
  exit 0
fi

# transactional run
if ((${#FILES[@]} == 0)); then usage; exit 2; fi

TMP="$(mktemp)"
trap 'rm -f -- "$TMP" "$TMP.out"' EXIT

TS="$(date +%Y%m%d%H%M%S%3N)"
for F in "${FILES[@]}"; do
  [[ -f "$F" ]] || continue
  if ((${#FILES[@]} > 1)); then
    cp -f -- "$F" "$F.ta_bak_g_$TS"
  else
    cp -f -- "$F" "$F.ta_bak_$TS"
  fi
done

cat >"$TMP"

_restore_this_run() {
  local F B
  for F in "${FILES[@]}"; do
    if ((${#FILES[@]} > 1)); then
      B="$F.ta_bak_g_$TS"
    else
      B="$F.ta_bak_$TS"
    fi
    [[ -f "$B" ]] || { echo "FATAL: snapshot for this run not found: $B" >&2; exit 2; }
    cp -f -- "$B" "$F" || { echo "FATAL: restore copy failed for $F" >&2; exit 2; }
    cmp -s "$B" "$F"   || { echo "FATAL: restore verification failed for $F" >&2; exit 2; }
    echo "ROLLED BACK $F from $B"
  done
}

set +e
bash -Eeuo pipefail "$TMP" >"$TMP.out" 2>&1
RC=$?
set -e

if (( RC != 0 )); then
  echo "FAILED  Transaction rolled back" >&2
  echo "--- RUN LOG (last 120 lines) ---"; tail -n 120 "$TMP.out" 2>/dev/null || true
  echo "--- SCRIPT ---"; nl -ba "$TMP" 2>/dev/null || true
  echo "--- DIFF vs snapshot (TS=$TS) ---"
  for F in "${FILES[@]}"; do
    if ((${#FILES[@]} > 1)); then B="$F.ta_bak_g_$TS"; else B="$F.ta_bak_$TS"; fi
    [[ -f "$B" ]] && diff -u --label "$B" --label "$F" "$B" "$F" || true
  done
  _restore_this_run
  exit "$RC"
fi

echo "--- SCRIPT ---"; nl -ba "$TMP" 2>/dev/null || true
echo "--- CHANGES vs snapshot (TS=$TS) ---"
for F in "${FILES[@]}"; do
  if ((${#FILES[@]} > 1)); then B="$F.ta_bak_g_$TS"; else B="$F.ta_bak_$TS"; fi
  if [[ -f "$B" ]]; then diff -u --label "$B" --label "$F" "$B" "$F" || true
  else echo "no backup for $F at TS=$TS"
  fi
done

echo "SUCCESS"
