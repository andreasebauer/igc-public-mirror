from __future__ import annotations
from pathlib import Path
from typing import Optional, List
import os

from fastapi import FastAPI, Request, Form, HTTPException, Query
from igc.gui.services.metrics_data import list_metric_groups, list_metrics_by_group, list_assigned_metrics
from fastapi.responses import RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from igc.gui.entry import list_actions, db_health, recent_sims
from igc.gui.create_sim import load_defaults, save_simulation, run_simulation
from igc.gui.data_select import describe_run, select_frame_range
from igc.gui.run_monitor import list_active_jobs, job_detail, requeue_job, cancel_job
from igc.gui.sim_flow import router as sim_router

app = FastAPI(title="IGC GUI")
# Apple touch icons (served from igc/gui/static/)

_STATIC_DIR = Path(__file__).resolve().parent / "static"

@app.get("/apple-touch-icon.png", include_in_schema=False)

def apple_touch_icon():

    return FileResponse(_STATIC_DIR / "apple-touch-icon.png", media_type="image/png", headers={"Cache-Control": "public, max-age=604800"})

@app.get("/apple-touch-icon-precomposed.png", include_in_schema=False)

def apple_touch_icon_precomposed():

    return FileResponse(_STATIC_DIR / "apple-touch-icon-precomposed.png", media_type="image/png", headers={"Cache-Control": "public, max-age=604800"})
BASE_DIR = Path(__file__).parent
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))
# expose registry in templates
from igc.gui.vars import VARS
try:
    templates.env.globals.update(VARS=VARS, keys=VARS.keys, routes=VARS.routes, ui=VARS.ui)
except Exception:
    pass

app.include_router(sim_router)
app.include_router(sim_router)
static_dir = BASE_DIR / "static"
static_dir.mkdir(exist_ok=True)
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")

@app.get("/")
def index(request: Request):
    health = db_health()
    sims = recent_sims()
    return templates.TemplateResponse("index.html", {"request": request, "health": health, "sims": sims, "actions": list_actions()})

@app.get("/sims/new")
def sims_new(request: Request, from_id: Optional[int] = None):
    defaults = load_defaults(from_id)
    return templates.TemplateResponse("sim_new.html", {"request": request, "d": defaults})

@app.post("/sims")
def sims_create(
    request: Request,
    label: str = Form(...),
    name: str = Form(...),
    gridx: int = Form(...),
    gridy: int = Form(...),
    gridz: int = Form(...),
    psi0_elsewhere: float = Form(...),
    psi0_center: float = Form(...),
    phi0: float = Form(1.0),
    eta0: float = Form(1e-12),
    substeps_per_at: int = Form(48),
    dt_per_at: float = Form(1.0),
    dx: float = Form(1.0)
):
    spec = dict(
        label=label, name=name,
        gridx=gridx, gridy=gridy, gridz=gridz,
        psi0_elsewhere=psi0_elsewhere, psi0_center=psi0_center,
        phi0=phi0, eta0=eta0,
        substeps_per_at=substeps_per_at, dt_per_at=dt_per_at, dx=dx
    )
    try:
        sim_id = save_simulation(spec)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)

@app.get("/sims/id/{sim_id}")
def sims_detail(request: Request, sim_id: int):
    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    sim = run["sim"]
    frames = run["frames"]
    return templates.TemplateResponse("sim_detail.html", {"request": request, "sim": sim, "frames": frames})

@app.post("/sims/id/{sim_id}/run")
def sims_run(sim_id: int, ats: int = Form(1), save_first: Optional[bool]=Form(False), stats: Optional[bool]=Form(False)):
    try:
        run_simulation(sim_id, ats=int(ats), save_first=bool(save_first), header_stats=bool(stats))
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)


@app.get("/jobs")
def jobs_page(request: Request, sim_id: Optional[int]=None, limit: int = 200):
    rows = list_active_jobs(sim_id=sim_id, limit=limit)
    return templates.TemplateResponse("jobs.html", {"request": request, "rows": rows, "sim_id": sim_id, "limit": limit, "header_right": "Running Jobs"})

@app.get("/jobs/{job_id}")
def job_page(request: Request, job_id: int):
    row = job_detail(job_id)
    if not row:
        raise HTTPException(status_code=404, detail="job not found")
    return templates.TemplateResponse("job_detail.html", {"request": request, "row": row})

@app.post("/jobs/{job_id}/requeue")
def job_requeue(job_id: int):
    requeue_job(job_id)
    return RedirectResponse(url=f"/jobs/{job_id}", status_code=303)

@app.post("/jobs/{job_id}/cancel")
def job_cancel(job_id: int):
    cancel_job(job_id)
    return RedirectResponse(url=f"/jobs/{job_id}", status_code=303)

# --- IGC VARS/URLQ REGISTRATION ---
try:
    from .vars import VARS
    from .utils import urlq
    # Expose registry + helper to all templates
    templates.env.globals.update(
        VARS=VARS,             # full registry
        routes=VARS.routes,    # shorthand: routes.*
        ui=VARS.ui,            # shorthand: ui.*
        keys=VARS.keys,        # shorthand: keys.*
        urlq=urlq,             # helper for query-string URLs
    )
except Exception as _e:
    # If templates is not defined here, ignore (some apps init elsewhere)
    pass

# ========== Metrics: SimPicker & Select (new) =================================
from igc.gui.services.simpicker_service import read_sim_meta
from igc.ledger.core import (
    upsert_pathregistry_simroot, sim_exists, load_metric_catalog_grouped,
    load_selected_metric_ids, overwrite_simmetricmatcher
)
from igc.oe.core import seed_metric_jobs
from fastapi import Form
from fastapi.responses import RedirectResponse

@app.get("/metrics/simpicker")
def metrics_simpicker(request: Request, base: str = "/data/simulations"):
    """Render the server-side folder picker at the given base path."""
    import os
    base_abs = os.path.abspath(base) if base else "/"
    if not os.path.isdir(base_abs):
        base_abs = "/"
    dirs = []
    try:
        for e in os.scandir(base_abs):
            if e.is_dir():
                dirs.append({"name": e.name, "path": os.path.join(base_abs, e.name)})
    except Exception:
        pass
    dirs.sort(key=lambda d: d["name"].lower())
    parent = os.path.dirname(base_abs.rstrip(os.sep)) or "/"
    browse = {"base": base_abs, "parent": parent, "dirs": dirs}
    return templates.TemplateResponse(
        "create_simpicker.html",
        {
            "request": request,
            "preview": {},
            "availability": {"frames": [], "phases": [0]},
            "error": None,
            "browse": browse,
            "back_url": "/",
            "primary_kind": "link",
            "primary_label": "Next",
            "primary_url": "#",
            "primary_disabled": True,
        },
    )

# ------------------ File-browse allowlist + API for jsTree -------------------
import os
from urllib.parse import unquote

# Only allow browsing under these absolute prefixes (no trailing slash required)
ALLOWLIST_PREFIXES = ("/data/simulations",)

def _canon_allowed(path: str) -> str | None:
    """Return canonical absolute path if it's inside one of ALLOWLIST_PREFIXES, else None."""
    if not path:
        return None
    p = os.path.abspath(os.path.expanduser(path))
    # Normalize and ensure p is within allowed prefixes
    for prefix in ALLOWLIST_PREFIXES:
        pref = os.path.abspath(os.path.expanduser(prefix))
        if p == pref or p.startswith(pref + os.sep):
            return p
    return None


@app.get("/api/fs_tree")
def api_fs_tree(
    base: str | None = Query(default=None),
    parent: str | None = Query(default=None),
):
    """
    JSON for jsTree: returns immediate subdirectories of the requested root.
    Accepts either ?base= or ?parent=. Falls back to the first allowed root.
    Example return: [{"id": "/data/in/A1", "text": "A1", "children": true}, ...]
    """
    from urllib.parse import unquote
    import os

    # Resolve raw -> absolute -> allowlisted
    raw = base or parent or "/data/simulations"
    raw = unquote(raw or "")
    # ALLOWLIST_PREFIXES and _canon_allowed must already exist in this module
    try:
        allowed = _canon_allowed(raw) or os.path.abspath(ALLOWLIST_PREFIXES[0])
    except NameError:
        # Fallback: basic allow under /data/in
        roots = ("/data/in",)
        p = os.path.abspath(os.path.expanduser(raw))
        allowed = p if any(p == r or p.startswith(r + os.path.sep) for r in roots) else roots[0]

    nodes = []
    try:
        for entry in os.scandir(allowed):
            if entry.is_dir(follow_symlinks=False):
                child = os.path.join(allowed, entry.name)
                nodes.append({"id": child, "text": entry.name, "children": True})
    except Exception:
        pass

    nodes.sort(key=lambda n: n["text"].lower())
    return nodes

# ----------  Preview partial (metrics/simpicker/preview) -----------------------
@app.get("/metrics/simpicker/preview")
def metrics_simpicker_preview(request: Request, path: str):
    """
    Serve the right-pane preview for the selected simulation folder.
    Accepts ?path= (absolute folder path). Reads sim_meta.json inside that folder.
    """
    from igc.gui.services.simpicker_service import read_sim_meta

    allowed = _canon_allowed(path)
    if allowed is None:
        return templates.TemplateResponse(
            "partials/preview_not_allowed.html",
            {"request": request, "path": path},
            status_code=403,
        )
    try:
        preview, availability = read_sim_meta(allowed)
        ctx = {
            "request": request,
            "preview": preview,
            "availability": availability,
            "browse": {"base": allowed},
        }
        return templates.TemplateResponse("partials/preview.html", ctx)
    except Exception as e:
        msg = str(e).lower()
        # suppress UI when sim_meta.json is simply missing in a selected folder
        if "sim_meta.json not found" in msg:
            # render empty (no text) instead of an error box
            return templates.TemplateResponse("partials/preview.html", {"request": request, "preview": {}, "availability": {"frames": [], "phases":[0]}, "browse":{"base": allowed}})
        ctx = {"request": request, "error": str(e), "path": allowed}
        return templates.TemplateResponse("partials/preview_error.html", ctx)
@app.get("/metrics/select/{sim_id}")
def metrics_select_page_new(request: Request, sim_id: int):
    # New metrics selection page (dual-list UI) — placeholders for now
    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    sim = run["sim"]
    groups = []  # TODO: load from metgroup_count
    metrics_by_group = {}  # TODO: load from metrics_group
    assigned_metric_ids = set()  # TODO: load from simmetricmatcher
    return templates.TemplateResponse(
        "metrics_select.html",
        {
            "request": request,
            "sim": sim,
            "groups": groups,
            "metrics_by_group": metrics_by_group,
            "assigned_metric_ids": assigned_metric_ids,
            "back_url": "/metrics/simpicker",
            "primary_kind": "link",
            "primary_label": "Next",
            "primary_url": "#",
            "primary_disabled": False,
            "header_right": f"{sim['label']} · {sim['name']}",
        },
    )


@app.post("/metrics/{sim_id}/save")
def metrics_save(sim_id: int, metric_ids: List[int] = Form([])):
    # Final save: toggle simmetricmatcher.enabled, updated_at
    # TODO: implement transactional upsert (disable removed; upsert selected)
    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)

@app.post("/metrics/{sim_id}/confirm")
def metrics_confirm(request: Request, sim_id: int, metric_ids: List[int] = Form([])):
    if not metric_ids:
        raise HTTPException(status_code=400, detail="No metrics selected.")

    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    sim = run["sim"]

    # Build grouped summary using data services
    selected = {int(x) for x in metric_ids}
    groups = list_metric_groups()                 # [{'id':1,'name':'observables','count':22}, ...]
    all_by_group = list_metrics_by_group()        # { group_id: [{id,name,desc,out}, ...], ... }

    confirm_groups = []
    for g in groups:
        gid = g["id"]
        gmets = [m for m in all_by_group.get(gid, []) if m["id"] in selected]
        confirm_groups.append({"id": gid, "name": g["name"], "metrics": gmets})

    return templates.TemplateResponse(
        "metrics_confirm.html",
        {
            "request": request,
            "sim": sim,
            "groups": confirm_groups,
            "total_selected": len(selected),
            "metric_ids": list(selected),
            "header_right": "Confirmation",
        },
    )

@app.post("/metrics/{sim_id}/save")
def metrics_save(sim_id: int, metric_ids: List[int] = Form([])):
    # Persist: enable selected; disable any previously enabled but not selected
    selected = {int(x) for x in metric_ids}

    from igc.db.pg import cx, fetchall_dict, execute

    with cx() as conn:
        # current enabled set
        rows = fetchall_dict(conn, "SELECT metric_id FROM simmetricmatcher WHERE sim_id=%s AND enabled=true", (sim_id,))
        current = {r["metric_id"] for r in rows}

        # disable removed
        to_disable = current - selected
        for mid in to_disable:
            execute(conn, "UPDATE simmetricmatcher SET enabled=false, updated_at=now() WHERE sim_id=%s AND metric_id=%s AND enabled=true", (sim_id, mid))

        # upsert selected -> enabled=true
        for mid in selected:
            execute(conn, """
                INSERT INTO simmetricmatcher (sim_id, metric_id)
                VALUES (%s, %s)
                ON CONFLICT (sim_id, metric_id)
                DO UPDATE SET enabled=true, updated_at=now()
            """, (sim_id, mid))

    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)
