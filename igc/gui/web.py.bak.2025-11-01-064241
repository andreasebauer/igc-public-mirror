from __future__ import annotations
from pathlib import Path
from typing import Optional, List
import os

from fastapi import FastAPI, Request, Form, HTTPException, Query
from fastapi.responses import RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from igc.gui.entry import list_actions, db_health, recent_sims
from igc.gui.create_sim import load_defaults, save_simulation, run_simulation
from igc.gui.data_select import describe_run, select_frame_range
from igc.gui.metrics_select import list_metrics_for_sim, validate_selection, seed_jobs_for_frames
from igc.gui.run_monitor import list_active_jobs, job_detail, requeue_job, cancel_job
from igc.gui.sim_flow import router as sim_router

app = FastAPI(title="IGC GUI")
BASE_DIR = Path(__file__).parent
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))
# expose registry in templates
from igc.gui.vars import VARS
try:
    templates.env.globals.update(VARS=VARS, keys=VARS.keys, routes=VARS.routes, ui=VARS.ui)
except Exception:
    pass

app.include_router(sim_router)
app.include_router(sim_router)
static_dir = BASE_DIR / "static"
static_dir.mkdir(exist_ok=True)
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")

@app.get("/")
def index(request: Request):
    health = db_health()
    sims = recent_sims()
    return templates.TemplateResponse("index.html", {"request": request, "health": health, "sims": sims, "actions": list_actions()})

@app.get("/sims/new")
def sims_new(request: Request, from_id: Optional[int] = None):
    defaults = load_defaults(from_id)
    return templates.TemplateResponse("sim_new.html", {"request": request, "d": defaults})

@app.post("/sims")
def sims_create(
    request: Request,
    label: str = Form(...),
    name: str = Form(...),
    gridx: int = Form(...),
    gridy: int = Form(...),
    gridz: int = Form(...),
    psi0_elsewhere: float = Form(...),
    psi0_center: float = Form(...),
    phi0: float = Form(1.0),
    eta0: float = Form(1e-12),
    substeps_per_at: int = Form(48),
    dt_per_at: float = Form(1.0),
    dx: float = Form(1.0)
):
    spec = dict(
        label=label, name=name,
        gridx=gridx, gridy=gridy, gridz=gridz,
        psi0_elsewhere=psi0_elsewhere, psi0_center=psi0_center,
        phi0=phi0, eta0=eta0,
        substeps_per_at=substeps_per_at, dt_per_at=dt_per_at, dx=dx
    )
    try:
        sim_id = save_simulation(spec)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)

@app.get("/sims/id/{sim_id}")
def sims_detail(request: Request, sim_id: int):
    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    sim = run["sim"]
    frames = run["frames"]
    return templates.TemplateResponse("sim_detail.html", {"request": request, "sim": sim, "frames": frames})

@app.post("/sims/id/{sim_id}/run")
def sims_run(sim_id: int, ats: int = Form(1), save_first: Optional[bool]=Form(False), stats: Optional[bool]=Form(False)):
    try:
        run_simulation(sim_id, ats=int(ats), save_first=bool(save_first), header_stats=bool(stats))
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    return RedirectResponse(url=f"/sims/id/{sim_id}", status_code=303)

@app.get("/metrics/{sim_id:int}")
def metrics_select_page(request: Request, sim_id: int):
    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    sim = run["sim"]
    frames = run["frames"]
    metrics = list_metrics_for_sim(sim_id)
    return templates.TemplateResponse("metrics_select.html", {"request": request, "sim": sim, "frames": frames, "metrics": metrics})

@app.post("/metrics/{sim_id}/seed")
def metrics_seed(sim_id: int, frame_start: int = Form(...), frame_end: int = Form(...), stride: int = Form(1), metric_ids: List[int] = Form([])):
    err = validate_selection(metric_ids)
    if err:
        raise HTTPException(status_code=400, detail="; ".join(err))
    run = describe_run(sim_id)
    if "error" in run:
        raise HTTPException(status_code=404, detail=run["error"])
    frames = select_frame_range(run["frames"], frame_start, frame_end, stride)
    if not frames:
        raise HTTPException(status_code=400, detail="no frames selected")
    seed_jobs_for_frames(sim_id, metric_ids, frames)
    return RedirectResponse(url=f"/jobs?sim_id={sim_id}", status_code=303)

@app.get("/jobs")
def jobs_page(request: Request, sim_id: Optional[int]=None, limit: int = 200):
    rows = list_active_jobs(sim_id=sim_id, limit=limit)
    return templates.TemplateResponse("jobs.html", {"request": request, "rows": rows, "sim_id": sim_id, "limit": limit})

@app.get("/jobs/{job_id}")
def job_page(request: Request, job_id: int):
    row = job_detail(job_id)
    if not row:
        raise HTTPException(status_code=404, detail="job not found")
    return templates.TemplateResponse("job_detail.html", {"request": request, "row": row})

@app.post("/jobs/{job_id}/requeue")
def job_requeue(job_id: int):
    requeue_job(job_id)
    return RedirectResponse(url=f"/jobs/{job_id}", status_code=303)

@app.post("/jobs/{job_id}/cancel")
def job_cancel(job_id: int):
    cancel_job(job_id)
    return RedirectResponse(url=f"/jobs/{job_id}", status_code=303)

# --- IGC VARS/URLQ REGISTRATION ---
try:
    from .vars import VARS
    from .utils import urlq
    # Expose registry + helper to all templates
    templates.env.globals.update(
        VARS=VARS,             # full registry
        routes=VARS.routes,    # shorthand: routes.*
        ui=VARS.ui,            # shorthand: ui.*
        keys=VARS.keys,        # shorthand: keys.*
        urlq=urlq,             # helper for query-string URLs
    )
except Exception as _e:
    # If templates is not defined here, ignore (some apps init elsewhere)
    pass

# ========== Metrics: SimPicker & Select (new) =================================
from igc.gui.services.simpicker_service import read_sim_meta
from igc.ledger.core import (
    upsert_pathregistry_simroot, sim_exists, load_metric_catalog_grouped,
    load_selected_metric_ids, overwrite_simmetricmatcher
)
from igc.oe.core import seed_metric_jobs
from fastapi import Form
from fastapi.responses import RedirectResponse

@app.get("/metrics/simpicker")
def metrics_simpicker(request: Request, base: str = "/data/sims"):
    """Render the server-side folder picker at the given base path."""
    import os
    base_abs = os.path.abspath(base) if base else "/"
    if not os.path.isdir(base_abs):
        base_abs = "/"
    dirs = []
    try:
        for e in os.scandir(base_abs):
            if e.is_dir():
                dirs.append({"name": e.name, "path": os.path.join(base_abs, e.name)})
    except Exception:
        pass
    dirs.sort(key=lambda d: d["name"].lower())
    parent = os.path.dirname(base_abs.rstrip(os.sep)) or "/"
    browse = {"base": base_abs, "parent": parent, "dirs": dirs}
    return templates.TemplateResponse(
        "create_simpicker.html",
        {
            "request": request,
            "preview": None,
            "availability": {"frames": [], "phases": [0]},
            "error": None,
            "browse": browse,
        },
    )

# ------------------ File-browse allowlist + API for jsTree -------------------
import os
from urllib.parse import unquote

# Only allow browsing under these absolute prefixes (no trailing slash required)
ALLOWLIST_PREFIXES = ("/data/in", "/data/simulations", os.path.expanduser("~/igc"))

def _canon_allowed(path: str) -> str | None:
    """Return canonical absolute path if it's inside one of ALLOWLIST_PREFIXES, else None."""
    if not path:
        return None
    p = os.path.abspath(os.path.expanduser(path))
    # Normalize and ensure p is within allowed prefixes
    for prefix in ALLOWLIST_PREFIXES:
        pref = os.path.abspath(os.path.expanduser(prefix))
        if p == pref or p.startswith(pref + os.sep):
            return p
    return None


@app.get("/api/fs_tree")
def api_fs_tree(
    base: str | None = Query(default=None),
    parent: str | None = Query(default=None),
):
    """
    JSON for jsTree: returns immediate subdirectories of the requested root.
    Accepts either ?base= or ?parent=. Falls back to the first allowed root.
    Example return: [{"id": "/data/in/A1", "text": "A1", "children": true}, ...]
    """
    from urllib.parse import unquote
    import os

    # Resolve raw -> absolute -> allowlisted
    raw = base or parent or "/data/in"
    raw = unquote(raw or "")
    # ALLOWLIST_PREFIXES and _canon_allowed must already exist in this module
    try:
        allowed = _canon_allowed(raw) or os.path.abspath(ALLOWLIST_PREFIXES[0])
    except NameError:
        # Fallback: basic allow under /data/in
        roots = ("/data/in",)
        p = os.path.abspath(os.path.expanduser(raw))
        allowed = p if any(p == r or p.startswith(r + os.path.sep) for r in roots) else roots[0]

    nodes = []
    try:
        for entry in os.scandir(allowed):
            if entry.is_dir(follow_symlinks=False):
                child = os.path.join(allowed, entry.name)
                nodes.append({"id": child, "text": entry.name, "children": True})
    except Exception:
        pass

    nodes.sort(key=lambda n: n["text"].lower())
    return nodes

# ----------  Preview partial (metrics/simpicker/preview) -----------------------
@app.get("/metrics/simpicker/preview")
def metrics_simpicker_preview(request: Request, path: str):
    """
    Serve the right-pane preview for the selected simulation folder.
    Accepts ?path= (absolute folder path). Reads sim_meta.json inside that folder.
    """
    from igc.gui.services.simpicker_service import read_sim_meta

    allowed = _canon_allowed(path)
    if allowed is None:
        return templates.TemplateResponse(
            "partials/preview_not_allowed.html",
            {"request": request, "path": path},
            status_code=403,
        )
    try:
        preview, availability = read_sim_meta(allowed)
        ctx = {
            "request": request,
            "preview": preview,
            "availability": availability,
            "browse": {"base": allowed},
        }
        return templates.TemplateResponse("partials/preview.html", ctx)
    except Exception as e:
        ctx = {"request": request, "error": str(e), "path": allowed}
        return templates.TemplateResponse("partials/preview_error.html", ctx)
