{% extends "base.html" %}

{# Footer: Back to sim flow; no primary action on viewer #}
{% set back_url = request.url_for('sim_start') %}
{% set primary_kind = 'link' %}
{% set primary_label = 'Close' %}
{% set primary_url = request.url_for('index') %}
{% set primary_disabled = False %}

{% block content %}
<section class="card oe-viewer">

  <!-- Row 1: Progress (20%) -->
  <div class="oe-progress">
    <div class="oe-progress-top">
      <div class="oe-progress-bar">
        <div class="oe-progress-fill" id="ov-fill" style="width: 0%"></div>
      </div>
      <div class="oe-progress-stats">
        <span class="pct"        id="ov-pct">0%</span>
        <span class="eta"        id="ov-eta">ETA —</span>
        <span class="bytes"      id="ov-bytes">0 / 0</span>
        <span class="throughput" id="ov-tp">—/s</span>
      </div>
    </div>
    <div class="oe-progress-sub" id="ov-sub">
      <!-- latest op e.g. RUNNING jobid=… frame=… metric=… step=… -->
    </div>
  </div>

  <!-- Row 2: Gauges (30%) -->
  <div class="oe-gauges">
    <div class="gauge card">
      <h3>CPU</h3>
      <div class="gauge-body" id="g-cpu">
        <div class="big" id="cpu-proc">0%</div>
        <div class="sub" id="cpu-sys">sys 0%</div>
      </div>
    </div>
    <div class="gauge card">
      <h3>RAM</h3>
      <div class="gauge-body" id="g-ram">
        <div class="big" id="ram-used">0 MB</div>
        <div class="sub" id="ram-pred">pred 0 MB</div>
      </div>
    </div>
    <div class="gauge card">
      <h3>Disk</h3>
      <div class="gauge-body" id="g-disk">
        <div class="big" id="disk-free">0 MB free</div>
        <div class="sub" id="bytes-written">written 0</div>
      </div>
    </div>

    <div class="gauge card">
      <h3>ψ / pₖ</h3>
      <div class="gauge-body">
        <img id="preview-psi" src="" alt="psi / p_k preview" style="width:100%; border-radius:4px; background:#000;" />
      </div>
    </div>
    <div class="gauge card">
      <h3>φ / mask</h3>
      <div class="gauge-body">
        <img id="preview-phi" src="" alt="phi / collapse_mask preview" style="width:100%; border-radius:4px; background:#000;" />
      </div>
    </div>
    <div class="gauge card">
      <h3>η / L</h3>
      <div class="gauge-body">
        <img id="preview-eta" src="" alt="eta / coherence_length preview" style="width:100%; border-radius:4px; background:#000;" />
      </div>
    </div>
  </div>

  <!-- Row 3: Logs (50%) -->
  <div class="oe-logs">
    <div class="oe-logs-toolbar">
      <span>Logs</span>
      <div class="spacer"></div>
      <button class="btn btn--sm btn--danger" id="btn-stop">Stop</button>
      <button class="btn btn--sm" disabled>Pause</button>
      <button class="btn btn--sm" disabled>Copy</button>
    </div>
    <div class="oe-logs-pane" id="oe-log">
      <!-- terminal-like lines; newest at bottom -->
    </div>
  </div>

</section>

<style>
/* --- OE viewer fixed 3-row layout --------------------------------------- */
.oe-viewer{
  display: grid;
  grid-template-rows: 1fr 2fr 7fr;
  gap: 16px;
  min-height: 70vh;           /* ensures sensible height inside main */
  height: 70vh;               /* definite height so rows don’t overflow */
}

/* Row 1: Progress */
.oe-progress{ display:grid; grid-template-rows:auto auto; row-gap:8px; }
.oe-progress-bar{ height:12px; background:#eee; border-radius:8px; overflow:hidden; }
.oe-progress-fill{ height:100%; background:#111; width:0%; }
.oe-progress-stats{ display:flex; gap:12px; font-variant-numeric: tabular-nums; }
.oe-progress-sub{ font-size:12px; opacity:.8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  /* Row 2: Gauges (3 equal columns) */
  .oe-gauges{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:16px; }
  .gauge.card{ display:grid; align-content:flex-start; text-align:center; }
  .gauge h3{ margin:0 0 8px 0; }
  .gauge .big{ font-size:28px; line-height:1; }
  .gauge .sub{ font-size:12px; opacity:.75; margin-top:6px; }

  /* Gauge previews: keep images compact so logs have space */
  .gauge img{
    max-height:80px;
    width:100%;
    object-fit:contain;
  }

/* Row 3: Logs */
.oe-logs{ display:grid; grid-template-rows: auto 1fr; min-height:0; }
.oe-logs-toolbar{ display:flex; align-items:center; gap:8px; }
.oe-logs-toolbar .spacer{ flex:1; }
.oe-logs-pane{
  border:1px solid var(--border);
  border-radius:8px;
  font: 13px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  padding:8px;
  overflow-y:auto;            /* right scrollbar */
  white-space:pre-wrap;       /* wrap long lines */
}
  .oe-logs-pane .log-line {
    font-weight: 400;
  }
  .oe-logs-pane .log-frame-ok {
    font-weight: 600;
  }
  .oe-logs-pane .log-final {
    font-weight: 700;
    color: #0a0;
  }
</style>
{% endblock %}
{% block page_js %}
<script>
(() => {
  const simId = {{ sim_id|int }};
  const logEl = document.getElementById('oe-log');
  if (!logEl) return;

  const fillEl  = document.getElementById('ov-fill');
  const pctEl   = document.getElementById('ov-pct');
  const etaEl   = document.getElementById('ov-eta');
  const bytesEl = document.getElementById('ov-bytes');
  const tpEl    = document.getElementById('ov-tp');
  const stopBtn = document.getElementById('btn-stop');

  if (stopBtn) {
    stopBtn.addEventListener('click', async () => {
      try {
        await fetch(`/sims/oe/run/${simId}/abort`, { method: "POST" });
      } catch {}
      window.location.href = "{{ request.url_for('index') }}";
    });
  }

  const cpuProcEl      = document.getElementById('cpu-proc');
  const cpuSysEl       = document.getElementById('cpu-sys');
  const ramUsedEl      = document.getElementById('ram-used');
  const ramPredEl      = document.getElementById('ram-pred');
  const diskFreeEl     = document.getElementById('disk-free');
  const bytesWrittenEl = document.getElementById('bytes-written');

  let afterId = 0;
  let viewerAfter = 0;
  let sweepLabel = "";
  let lastPct = 0;

  // Aggregation state for metric jobs: sum durations per (frame, metric) within a run
  const metricAgg = new Map();    // key "frame::name" -> total ms in this metrics run
  const metricLines = new Map();  // key "frame::name" -> DOM element

  // Track durations per job so we can estimate metric runtimes
  const jobDur = new Map();       // key jobid -> last frame_done ms

  // Track metric log lines per frame so we can prune older frames from the log.
  const frameOrder = [];          // list of frame identifiers in order of appearance
  const frameNodes = new Map();   // frameKey -> [DOM nodes for that frame]

  const resetMetricAggregation = () => {
    // Remove metric lines from the log pane
    metricLines.forEach((div) => {
      if (div && div.parentNode) {
        div.parentNode.removeChild(div);
      }
    });
    metricLines.clear();
    metricAgg.clear();
    jobDur.clear();
    frameOrder.length = 0;
    frameKeys.clear();
  };

  const MAX_LOG_LINES = 500; // hard cap for all log lines in the viewer

  const appendLine = (txt, className) => {
    if (!logEl) return;

    const atBottom = Math.abs(logEl.scrollHeight - (logEl.scrollTop + logEl.clientHeight)) < 8;

    const div = document.createElement('div');
    div.className = className ? `log-line ${className}` : 'log-line';
    div.textContent = txt;
    logEl.appendChild(div);

    // Global pruning: keep only the last MAX_LOG_LINES entries in the log pane.
    // Remove older nodes from the top to keep the DOM small and responsive.
    const children = logEl.children;
    const extra = children.length - MAX_LOG_LINES;
    if (extra > 0) {
      for (let i = 0; i < extra; i++) {
        const node = children[0];
        if (node) {
          logEl.removeChild(node);
        }
      }
    }

    if (atBottom) {
      logEl.scrollTop = logEl.scrollHeight;
    }
  };

  // backward-compatible helper
  const append = (txt) => appendLine(txt, '');

  async function pollProgress() {
    try {
      const r = await fetch(`/sims/oe/run/${simId}/progress`, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const p = await r.json() || {};

      const t = p.totals || {};
      const total   = Number(t.total_jobs   ?? 0);
      const done    = Number(t.done_jobs    ?? 0);
      const running = Number(t.running_jobs ?? 0);
      const failed  = Number(t.failed_jobs  ?? 0);

      let pct = (typeof p.percent === "number" && Number.isFinite(p.percent))
        ? p.percent
        : (total > 0 ? (done / total) * 100.0 : 0);

      let pctInt = Math.floor(pct);
      if (!Number.isFinite(pctInt) || pctInt < 0) pctInt = 0;

      // clamp to be monotonic: never go backwards
      if (pctInt < lastPct) {
        pctInt = lastPct;
      }
      lastPct = pctInt;

      if (fillEl) fillEl.style.width = `${pctInt}%`;
      if (pctEl)  pctEl.textContent  = `${pctInt}%`;

      const b = p.bytes || {};
      if (bytesEl && (b.written != null || b.expected != null)) {
        const bw = Number(b.written  ?? 0);
        const bt = Number(b.expected ?? 0);
        bytesEl.textContent = `${bw.toLocaleString()} / ${bt.toLocaleString()}`;
      }

      // Throughput: show MB/s if we have a value, else "—"
      if (tpEl && p.throughput_bps != null && p.throughput_bps > 0) {
        const mbps = p.throughput_bps / (1024 * 1024);
        tpEl.textContent = `${mbps.toFixed(2)} MB/s`;
      } else if (tpEl) {
        tpEl.textContent = "—";
      }

      // ETA: format as MM:SS if we have a positive estimate, else "ETA —"
      if (etaEl && p.eta_seconds != null && p.eta_seconds > 0) {
        const s = Math.round(p.eta_seconds);
        const mm = String(Math.floor(s / 60)).padStart(2, "0");
        const ss = String(s % 60).padStart(2, "0");
        etaEl.textContent = `ETA ${mm}:${ss}`;
      } else if (etaEl) {
        etaEl.textContent = "ETA —";
      }

      const sub = document.getElementById("ov-sub");
      if (sub) {
        if (total > 0) {
          const statsText = `done ${done}/${total} • running ${running} • failed ${failed}`;
          sub.textContent = sweepLabel
            ? `${sweepLabel} · ${statsText}`
            : statsText;
        } else {
          // no jobs yet — show sweep status if we have it, else a generic message
          sub.textContent = sweepLabel || "Preparing runs…";
        }
      }
    } catch (e) {
      /* ignore */
    } finally {
      setTimeout(pollProgress, 1000);
    }
  }

  async function pollGauges() {
    try {
      const r = await fetch(`/sims/oe/run/${simId}/gauges`, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const g = await r.json() || {};

      if (cpuProcEl && g.cpu_pct_proc != null) {
        cpuProcEl.textContent = `${Math.round(g.cpu_pct_proc)}%`;
      }
      if (cpuSysEl && g.cpu_pct_sys != null) {
        cpuSysEl.textContent = `sys ${Math.round(g.cpu_pct_sys)}%`;
      }
      if (ramUsedEl && g.ram_used_mb != null) {
        ramUsedEl.textContent = `${Math.round(g.ram_used_mb)} MB`;
      }
      if (ramPredEl && g.mem_predicted_mb != null) {
        ramPredEl.textContent = `pred ${Math.round(g.mem_predicted_mb)} MB`;
      }
      if (diskFreeEl && g.disk_free_mb != null) {
        diskFreeEl.textContent = `${Math.round(g.disk_free_mb)} MB free`;
      }
      if (bytesWrittenEl && g.bytes_written != null) {
        bytesWrittenEl.textContent = `written ${Number(g.bytes_written).toLocaleString()}`;
      }
    } catch (e) {
      /* ignore */
    } finally {
      setTimeout(pollGauges, 100);
    }
  }

  async function poll() {
    try {
      const r = await fetch(`/sims/oe/run/${simId}/logs?after_id=${afterId}&viewer_after=${viewerAfter}&limit=200`, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const data = await r.json();

      // sim-level notes (non-durable)
      if (Array.isArray(data.notes)) {
        for (const n of data.notes) {
          if (n && n.message) {
            const msg = n.message;
            appendLine(`[note] ${msg}`, 'log-note');

            // If this is a sweep note, reuse it in the progress header
            if (msg.startsWith("[sweep]")) {
              sweepLabel = msg.replace(/^\[sweep\]\s*/, "");

              const sub = document.getElementById("ov-sub");
              if (sub) {
                // temporary: will be combined with stats on next pollProgress
                sub.textContent = sweepLabel;
              }
            }
          }
         }
       }
      // in-memory viewer events: frame_start, file_written, frame_done, run_complete
      if (Array.isArray(data.viewer)) {
        for (const e of data.viewer) {
          const st    = e.status || '';
          const frame = e.frame; 
          const durMs = e.ms || 0
          
          // Sweep note events from in-memory viewer (e.g. metrics sweep 1 of N)
          if (st === 'note' && e.message && e.message.startsWith("[sweep]")) {
            const msg = e.message;

            // Show the sweep line in the log pane
            appendLine(msg, 'log-note');

            // Reflect this in the overview subtitle
            const sub = document.getElementById("ov-sub");
            if (sub) {
              const label = msg.replace(/^\[sweep\]\s*/, "");
              sub.textContent = label;
            }

            continue;
          }      

          // Run-level start events
          if (st === 'run_sim_start') {
            appendLine('Simulation will start soon…', 'log-note');
            continue;
          }
          if (st === 'run_metrics_start') {
            appendLine('Metrics run will start soon…', 'log-note');

            // NEW: reset metric aggregation for this metrics run, but keep
            // existing log lines so prior runs (or sweep members) stay visible.
            metricAgg.clear();
            metricLines.clear();

            continue;
          }
          if (st === 'run_both_start') {
            appendLine('Simulation and metrics run will start soon…', 'log-note');
            continue;
          }
                    
          if (st === 'frame_done' && frame != null) {
            // Metrics: frame_done events from metric jobs (jobid != null) are used
            // only to accumulate runtimes; do not spam the log.
            if (e.jobid != null) {
              jobDur.set(e.jobid, durMs);
              continue;
            }

            // Simulation frames: these come from the integrator callback (on_frame_saved)
            // with no jobid; show a concise per-frame line and update previews.
            const sec = (durMs / 1000).toFixed(2);
            appendLine(`Frame ${frame} has been saved to disk. (runtime ${sec}s)`, 'log-note');

            const psiImg = document.getElementById('preview-psi');
            const phiImg = document.getElementById('preview-phi');
            const etaImg = document.getElementById('preview-eta');

            const ts = Date.now();
            if (psiImg) {
              psiImg.src = `/sims/${simId}/frames/${frame}/preview/psi?ts=${ts}`;
            }
            if (phiImg) {
              phiImg.src = `/sims/${simId}/frames/${frame}/preview/phi?ts=${ts}`;
            }
            if (etaImg) {
              etaImg.src = `/sims/${simId}/frames/${frame}/preview/eta?ts=${ts}`;
            }

            continue;
          }

          // Run-level completion events (new statuses)
          if (st === 'run_sim_complete' || st === 'run_metrics_complete' || st === 'run_both_complete' || st === 'run_complete') {
            const sec = (durMs / 1000).toFixed(2);
            if (st === 'run_metrics_complete') {
              appendLine(`Metrics run has finished in ${sec}s.`, 'log-final');
            } else if (st === 'run_both_complete') {
              appendLine(`Simulation and metrics run have finished in ${sec}s.`, 'log-final');
            } else {
              // covers run_sim_complete and legacy run_complete
              appendLine(`Simulation data has been created. Run is finished in ${sec}s.`, 'log-final');
            }
            continue;
          }

          // Metric job events
          if (st === 'metric_start') {
            // suppress step-level spam
            continue;
          }

          if (st === 'metric_done') {
            const name = e.filename || '';
            const frVal = (frame != null ? frame : '?');
            const frKey = (frVal === '?' ? '?' : String(frVal));
            const key   = `${frKey}::${name}`;

            // Use stored job duration if available; otherwise fall back to e.ms
            let addMs = 0;
            if (e.jobid != null && jobDur.has(e.jobid)) {
              addMs = jobDur.get(e.jobid) || 0;
            } else if (typeof durMs === "number") {
              addMs = durMs;
            }

            const prevMs  = metricAgg.get(key) || 0;
            const totalMs = prevMs + addMs;
            metricAgg.set(key, totalMs);

            const sec  = (totalMs / 1000).toFixed(2);
            const text = `Frame ${frVal} Metric ${name} has been written to disk (runtime ${sec}s)`;

            // Update metric previews for selected metrics.
            // collapse_mask → φ preview
            if (name && name.includes("collapse_mask")) {
              const phiImg = document.getElementById('preview-phi');
              if (phiImg) {
                const ts = Date.now();
                phiImg.src = `/sims/${simId}/frames/${frVal}/preview/collapse_mask?ts=${ts}`;
              }
            }

            // p_k → ψ preview
            if (name && name.includes("p_k")) {
              const psiImg = document.getElementById('preview-psi');
              if (psiImg) {
                const ts = Date.now();
                psiImg.src = `/sims/${simId}/frames/${frVal}/preview/p_k?ts=${ts}`;
              }
            }

            // coherence_length → η preview
            if (name && name.includes("coherence_length")) {
              const etaImg = document.getElementById('preview-eta');
              if (etaImg) {
                const ts = Date.now();
                etaImg.src = `/sims/${simId}/frames/${frVal}/preview/coh_length?ts=${ts}`;
              }
            }

            const atBottom = Math.abs(logEl.scrollHeight - (logEl.scrollTop + logEl.clientHeight)) < 8;

            // Update or create a single log line for this (frame, metric)
            let div = metricLines.get(key);
            if (!div) {
              div = document.createElement('div');
              div.className = 'log-line log-note';
              logEl.appendChild(div);
              metricLines.set(key, div);

              // Track this line by frame so we can prune old frames
              if (!frameNodes.has(frKey)) {
                frameNodes.set(frKey, []);
                frameOrder.push(frKey);
              }
              frameNodes.get(frKey).push(div);
            }
            div.textContent = text;

            if (atBottom) {
              logEl.scrollTop = logEl.scrollHeight;
            }

            // Prune older frames so we only keep the last 50 frames in the log
            while (frameOrder.length > 50) {
              const oldFr = frameOrder.shift();
              const nodesForFrame = frameNodes.get(oldFr) || [];
              for (const node of nodesForFrame) {
                if (node && node.parentNode) {
                  node.parentNode.removeChild(node);
                }
              }
              frameNodes.delete(oldFr);

              // Optionally clean metricLines entries whose nodes were removed
              for (const [k, node] of metricLines.entries()) {
                if (!node || !node.parentNode) {
                  metricLines.delete(k);
                  metricAgg.delete(k);
                }
              }
            }

            continue;
          }

          // fallback: original raw line for other statuses
          const jid = (e.jobid != null) ? ` job=${e.jobid}` : '';
          const fr  = (frame != null) ? ` frame=${frame}` : '';
          const fn  = e.filename ? ` ${e.filename}` : '';
          const pth = e.path ? ` — ${e.path}` : '';
          const dur = (durMs && st === 'frame_done') ? ` — runtime_ms=${durMs}` : '';
          appendLine(`${st}${jid}${fr}${fn}${pth}${dur}`.trim(), '');
        }
        viewerAfter = data.viewer_next || viewerAfter;
      }

      // DB-backed items (if backend still sends them; may be empty)
      if (Array.isArray(data.items)) {
        for (const it of data.items) {
          const ts  = it.recorded_at || '';
          const st  = it.status || '';
          const jid = (it.jobid != null) ? ` job=${it.jobid}` : '';
          const fr  = (it.frame != null) ? ` frame=${it.frame}` : '';
          const rawMsg = it.message || '';
          const msg = rawMsg
            ? ` — ${rawMsg}`
            : (it.output_path ? ` — ${it.output_path}` : '');

          // If this DB-backed message is a sweep note, reuse it in the header as well.
          // Metrics sweep messages from metrics_save arrive here via _simlog_append.
          if (rawMsg.startsWith("[sweep]")) {
            sweepLabel = rawMsg.replace(/^\[sweep\]\s*/, "");

            const sub = document.getElementById("ov-sub");
            if (sub) {
              sub.textContent = sweepLabel;
            }
          }

          append(`${ts} ${st}${jid}${fr}${msg}`.trim());
          afterId = Math.max(afterId, Number(it.logid || 0));
        }
      }
    } catch (e) {
      // keep trying, but don’t spam the pane
    } finally {
      setTimeout(poll, 200);
    }
  }

  poll();
  pollProgress();
  pollGauges();
})();
</script>
{% endblock %}