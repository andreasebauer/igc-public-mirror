{% extends "base.html" %}
{% import "_components.html" as ui %}

{% block main_full %}
  <div class="metrics-fullgrid">
    <div class="col-left">
  <form id="metricsForm" method="post" action="/metrics/{{ sim.id }}/confirm" class="stack">
    <input type="hidden" name="run_root" value="{{ run_root }}"/>
    <section class="group-grid">
      {% for g in groups %}
        <div class="group-card">
          <div class="group-head">
            <h3>{{ g.name }} <span class="muted">({{ g.count }})</span></h3>
          </div>
          <div class="group-body">
            {# Build JSON-like arrays for items and preselected ids, using only Jinja basics #}
            {% set items = [] %}
            {% for m in metrics_by_group.get(g.id, []) %}
              {% set desc  = (m.desc | default('', true) | string) %}
              {% set label = (m.name        | default('', true) | string) %}
              {% set val   = m.id %}
              {% set _ = items.append({"value": val, "label": label, "desc": desc}) %}
            {% endfor %}

            {% set pre = [] %}
            {% for m in metrics_by_group.get(g.id, []) %}
              {% if m.id in assigned_metric_ids %}
                {% set _ = pre.append(m.id) %}
              {% endif %}
            {% endfor %}
      <div class="lists-2col">
        <div class="list-frame">
          <vaadin-dual-list-box class="metric-transfer" data-group="{{ g.id }}" data-items='{{ items|tojson }}' data-selected='{{ pre|tojson }}'></vaadin-dual-list-box>
        </div>
      </div>
      <div class="mini-ctrl" style="margin-top:6px; display:flex; gap:8px; justify-content:flex-start;">
        <button class="btn small btn--w-44" type="button" data-move-one="left"  data-group="{{ g.id }}">←</button>
        <button class="btn small btn--w-88" type="button" data-action="select-all" data-group="{{ g.id }}">Select all</button>
        <button class="btn small btn--w-88" type="button" data-action="deselect-all" data-group="{{ g.id }}" style="margin-left:auto">Deselect all</button>
        <button class="btn small btn--w-44" type="button" data-move-one="right" data-group="{{ g.id }}">→</button>
      </div>  <!-- /.mini-ctrl -->
      </div> <!-- /.group-body -->
    </div>   <!-- /.group-card -->      
      {% endfor %}
    </section>
  </form>
    </div> <!-- /.col-left -->
    <aside class="col-right">
      {% if is_sweep %}
      <section class="desc-card">
        <h3 class="desc-title">Sweep</h3>
        <div class="desc-body">
          <p class="muted">
            Sweep over {{ sweep_count }} runs
            {% if sweep_d_psi_start is not none and sweep_d_psi_end is not none %}
              · d_ψ: {{ sweep_d_psi_start }} → {{ sweep_d_psi_end }}
              {% if sweep_d_psi_step is not none %}
                (Δ ≈ {{ sweep_d_psi_step }})
              {% endif %}
            {% endif %}
          </p>
        </div>
      </section>
      {% endif %}
      <section id="metric-desc" class="desc-card">
        <h3 class="desc-title">Description</h3>
        <div class="desc-body muted">Select a metric to see its description here.</div>
      </section>
    </aside>
  </div> <!-- /.metrics-fullgrid -->

{% endblock %}
{% block page_js %}
<script>
(function(){
  class VDualListBox extends HTMLElement {
    constructor(){ super();  this._items=[]; this._selected=[]; }
    
    moveRightSelected(){
      const left = this.querySelector('.left'); if(!left) return;
      const sel = [...left.selectedOptions].map(o=>String(o.value));
      if(!sel.length) return;
      const add = new Set(sel);
      const before = new Set((this._selected||[]).map(it=>String(it.value)));
      (this._items||[]).forEach(it=>{ if(add.has(String(it.value)) && !before.has(String(it.value))) (this._selected||[]).push(it); });
      this._render(); this._emit();
    }
    moveLeftSelected(){
      const right = this.querySelector('.right'); if(!right) return;
      const rem = new Set([...right.selectedOptions].map(o=>String(o.value)));
      if(!rem.size) return;
      this._selected = (this._selected||[]).filter(it=>!rem.has(String(it.value)));
      this._render(); this._emit();
    }
    get items(){ return this._items; }
    set items(arr){
      this._items = Array.isArray(arr) ? arr.map(it => ({value:String(it.value), label:String(it.label)})) : [];
      this._render();
    }
    get selectedItems(){ return this._selected.slice(); }
    set selectedItems(arr){
      const vals = new Set((arr||[]).map(it => String(it.value)));
      this._selected = this._items.filter(it => vals.has(String(it.value)));
      this._render();
      this._emit();
    }
      _emit(){
      this.dispatchEvent(new CustomEvent('selected-items-changed', { bubbles: true }));
    }
   
    connectedCallback(){
      try { this._items = JSON.parse(this.getAttribute('data-items')||'[]'); } catch(e){ this._items=[]; }
      let pre=[]; try { pre = JSON.parse(this.getAttribute('data-selected')||'[]'); } catch(e){}
      const vals = new Set((pre||[]).map(v => String(v)));
      this._selected = this._items.filter(it => vals.has(String(it.value)));
      this._render();
    }
        _emitPreview(item){
      this.dispatchEvent(new CustomEvent('preview-item-changed', {
        bubbles: true,
        detail: { item }
      }));
    }
    _render(){
      const sel = new Set(this._selected.map(it=>String(it.value)));
      const avail = this._items;
      const right = this._selected;

      this.innerHTML = `
        <style>
          :host{display:block}
          .wrap{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  /* Force non-native paint so option background can be styled (WebKit) */
  select{ -webkit-appearance:none; appearance:none; }

  /* Black highlight for selected options */
  select option:checked{
    background:#000 !important;
    background-color:#000 !important;
    background-image:linear-gradient(#000,#000) !important; /* WebKit paint */
    color:#fff !important;
    -webkit-text-fill-color:#fff; /* Safari text paint */
    text-shadow:none;
  }
  /* Keep same paint when focused */
  select:focus option:checked{
    background:#000 !important; color:#fff !important; -webkit-text-fill-color:#fff;
  }

  /* Right list: neutralize preselected paint */
.right option:checked{
  background:#fff !important;
  background-color:#fff !important;
  background-image:linear-gradient(#fff,#fff) !important;
  color:#111 !important;
  -webkit-text-fill-color:#111;
  text-shadow:none;
}

  /* Dont dim “already moved” items when theyre the active selection */
  .left option.is-selected:checked{ opacity:1 !important; }
          .left option.is-selected{opacity:.55;}
  .wrap{grid-template-columns:1fr 1fr !important;}
  .list-frame select{border:none;outline:none;width:100%;}
  .list-frame select{border:none;outline:none;width:100%;}
  .list-frame select{border:none;outline:none;width:100%;}
</style>
          <div class="wrap">
          <select multiple class="left">${avail.map(it=>`<option value="${it.value}">${it.label}</option>`).join("")}</select>
          <select multiple class="right" name="metric_ids">${right.map(it=>`<option selected value="${it.value}">${it.label}</option>`).join("")}</select>
          </div>
      `;

      const left  = this.querySelector('.left');
      const rightSel = this.querySelector('.right');
      const previewFromLeft = () => {
        if(!left) return;
        const o = left.selectedOptions[left.selectedOptions.length - 1];
        if(!o){ this._emitPreview(null); return; }
        const val = String(o.value);
        const it = (this._items || []).find(x => String(x.value) === val) || null;
        this._emitPreview(it);
      };
      left.addEventListener('change', previewFromLeft);
      left.addEventListener('click',  previewFromLeft);
      left.addEventListener('keyup', (e)=>{
        if(e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'Home' || e.key === 'End'){
          previewFromLeft();
        }
      });

      // show all rows (no collapsed 4-row select by default)
      if (left){ left.setAttribute("size", String((this._items||[]).length || 1)); }
      if (rightSel){ rightSel.setAttribute("size", String((this._selected||[]).length || 1)); }
      const move = (src, addToRight) => {
        const moved=[]; [...src.selectedOptions].forEach(opt=>{
          // size left to full catalog (no scrollbar) and grey selected
          if (left){ left.setAttribute("size", String((this._items||[]).length || 1)); }
          this.querySelectorAll(".left option").forEach(o => {
            if ((new Set(this._selected.map(it=>String(it.value)))).has(String(o.value))){
              o.classList.add("is-selected"); o.setAttribute("data-selected","1");
            }
          });
          const val=String(opt.value);
          const obj=this._items.find(o=>String(o.value)===val);
          if(!obj) return;
          if(addToRight){
            if(!this._selected.some(o=>String(o.value)===val)) this._selected.push(obj);
          }else{
            this._selected=this._selected.filter(o=>String(o.value)!==val);
          }
          moved.push(obj);
        });
          if(moved.length){
            this._emitPreview(moved[moved.length - 1]);
            this._render();
            this._emit();
         }
      };

      // double-click to move
      left.addEventListener('dblclick', ()=>move(left,true));
      rightSel.addEventListener('dblclick', ()=>move(rightSel,false));
      // keyboard Enter to move
      left.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); move(left,true); }});
      rightSel.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); move(rightSel,false); }});
    }
  }
  if(!customElements.get('vaadin-dual-list-box')) customElements.define('vaadin-dual-list-box', VDualListBox);
})();
  // === Wire group mini-controls (←, →, Select all, Deselect all) =========
  document.querySelectorAll(".mini-ctrl").forEach(ctrl=>{
    const card = ctrl.closest(".group-card");
    const lb   = card ? card.querySelector("vaadin-dual-list-box.metric-transfer") : null;
    if(!lb) return;

    ctrl.addEventListener("click",(e)=>{
      const btn = e.target.closest("button");
      if(!btn) return;

      if (btn.dataset.action === "select-all"){
        // select all items in this listbox
        lb.selectedItems = lb.items || [];
        // preview last item for the right pane
        const all = lb.items || [];
        const last = all[all.length-1] || null;
        if(last) lb.dispatchEvent(new CustomEvent("preview-item-changed",{bubbles:true, detail:{item:last}}));
        return;
      }
      if (btn.dataset.action === "deselect-all"){
        lb.selectedItems = [];
        lb.dispatchEvent(new CustomEvent("preview-item-changed",{bubbles:true, detail:{item:null}}));
        return;
      }
      if (btn.dataset.moveOne === "left"){
        // remove selected from the RIGHT list
        lb.moveLeftSelected();
        return;
      }
      if (btn.dataset.moveOne === "right"){
        // move selected from the LEFT list to RIGHT
        lb.moveRightSelected();
        return;
      }
    });
  });
  // === Right pane: live description =======================================
  document.addEventListener('selected-items-changed', (e)=>{
    const lb = e.target && e.target.closest && e.target.closest('vaadin-dual-list-box');
    if(!lb) return;
    const sel = lb.selectedItems || [];
    const last = sel[sel.length - 1] || null;

    const box = document.getElementById('metric-desc');
    if(!box) return;
    const title = box.querySelector('.desc-title');
    const body  = box.querySelector('.desc-body');

    if(last){
      if(title) title.textContent = last.label || 'Description';
      if(body)  body.textContent  = (last.desc && String(last.desc).trim())
        ? String(last.desc)
        : `Metric: ${last.label} (id ${last.value})`;
    }else{
      if(title) title.textContent = 'Description';
      if(body)  body.textContent  = 'Select a metric to see its description here.';
    }
  });    
      // Right pane: live description
  document.addEventListener('preview-item-changed', (e)=>{
    const it   = e.detail && e.detail.item;
    const box  = document.getElementById('metric-desc');
    if(!box) return;
    const title = box.querySelector('.desc-title');
    const body  = box.querySelector('.desc-body');

    if(it){
      if(title) title.textContent = it.label || 'Description';
      if(body)  body.textContent  = (it.desc && String(it.desc).trim())
        ? String(it.desc)
        : `Metric: ${it.label} (id ${it.value})`;
    }else{
      if(title) title.textContent = 'Description';
      if(body)  body.textContent  = 'Select a metric to see its description here.';
    }
  });
    // === Align right description vertically with the selected metric ===========
  (function(){
    const aside = document.querySelector('aside.col-right');
    const desc  = document.getElementById('metric-desc');
    if(!aside || !desc) return;

    function alignDescToSelected(lb){
      if(!lb) return;
      const left = lb.querySelector('.left');
      if(!left || !left.selectedOptions || !left.selectedOptions.length) {
        desc.style.transform = 'translateY(0)';
        return;
      }
      const opt = left.selectedOptions[left.selectedOptions.length - 1];
      const leftRect  = left.getBoundingClientRect();
      const optRect   = opt.getBoundingClientRect();
      const asideRect = aside.getBoundingClientRect();
      const y = (optRect.top - asideRect.top) - 8;
      const maxY = Math.max(0, leftRect.height - desc.offsetHeight);
      const clamped = Math.max(0, Math.min(y, maxY));
      desc.style.transform  = `translateY(${Math.round(clamped)}px)`;
    }

    document.addEventListener('preview-item-changed', (e)=>{
      const lb = e.target && e.target.closest && e.target.closest('vaadin-dual-list-box');
      alignDescToSelected(lb);
    });
    document.addEventListener('selected-items-changed', (e)=>{
      const lb = e.target && e.target.closest && e.target.closest('vaadin-dual-list-box');
      alignDescToSelected(lb);
    });
    window.addEventListener('resize', ()=>{
      const lb = document.querySelector('vaadin-dual-list-box.metric-transfer');
      alignDescToSelected(lb);
    });
    window.addEventListener('scroll', ()=>{
      const lb = document.querySelector('vaadin-dual-list-box.metric-transfer');
      alignDescToSelected(lb);
    });
  })();
  // === Footer "Next": enable when selection exists; submit the form ===========
  (function(){
    const form  = document.getElementById('metricsForm');
    const next  = document.querySelector('footer.card .actions-right button[type=submit]');
    if(!form || !next) return;

    function totalSelected(){
      let n = 0;
      document.querySelectorAll('vaadin-dual-list-box.metric-transfer').forEach(lb=>{
        if (lb && Array.isArray(lb.selectedItems)) n += lb.selectedItems.length;
      });
      return n;
    }

    function setNextEnabled(enabled){
      if (enabled){
        next.classList.remove('is-disabled');
        next.removeAttribute('aria-disabled');
        next.removeAttribute('disabled');
      } else {
        next.classList.add('is-disabled');
        next.setAttribute('aria-disabled','true');
        next.setAttribute('disabled','true');
      }
    }

    // Update on any selection change (your component already emits this)
    document.addEventListener('selected-items-changed', ()=>{
      setNextEnabled(totalSelected() > 0);
    });

    // Initial state (pre-assigned metrics may already be selected)
    setNextEnabled(totalSelected() > 0);

    // Click => submit form if enabled
    next.addEventListener('click', (e)=>{
      if(next.classList.contains('is-disabled')) return; // do nothing
      e.preventDefault();
      form.submit();
    });
  })();  
</script>
{% endblock %}
